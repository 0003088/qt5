#!/usr/bin/env perl
#############################################################################
##
## Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
## All rights reserved.
## Contact: Nokia Corporation (qt-info@nokia.com)
##
## This file is part of the utilities of the Qt Toolkit.
##
## $QT_BEGIN_LICENSE:LGPL$
## No Commercial Usage
## This file contains pre-release code and may not be distributed.
## You may use this file in accordance with the terms and conditions
## contained in the Technology Preview License Agreement accompanying
## this package.
##
## GNU Lesser General Public License Usage
## Alternatively, this file may be used under the terms of the GNU Lesser
## General Public License version 2.1 as published by the Free Software
## Foundation and appearing in the file LICENSE.LGPL included in the
## packaging of this file.  Please review the following information to
## ensure the GNU Lesser General Public License version 2.1 requirements
## will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
##
## In addition, as a special exception, Nokia gives you certain additional
## rights.  These rights are described in the Nokia Qt LGPL Exception
## version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
##
## If you have questions regarding the use of this file, please contact
## Nokia at qt-info@nokia.com.
##
##
##
##
##
##
##
##
## $QT_END_LICENSE$
##
#############################################################################

use v5.10;
use strict;
use warnings;

package Qt::InitRepository;


=head1 NAME

init-repository - initialize the Qt5 repository and all submodules

=head1 SYNOPSIS

  ./init-repository [options]

This script may be run after an initial `git clone' of Qt5 in order to check
out all submodules.


=head1 OPTIONS

B<Global options:>

=over

=item --force, -f

Force initialization (even if the submodules are already checked out).


=item --quiet, -q

Be quiet.  Will exit cleanly if the repository is already initialized.

=back


B<Module options:>

=over

=item --no-webkit

Skip webkit and webkit examples submodules.
It may be desirable to skip these modules due to the large size of the webkit
git repository.


=item --no-update

Skip the `git submodule update' command.


=item --ignore-submodules

Set git config to ignore submodules by default when doing operations on the
qt5 repo, such as `pull', `fetch', `diff' etc.

This option is default for --nokia-developer/--brisbane.

After using this option, pass `--ignore-submodules=none' to git to override
it as needed.

=back


B<Repository options:>

=over

=item --nokia-developer

Switch to internal Nokia URLs.


=item --brisbane

Switch to internal Nokia URLs and make use of the Brisbane git mirrors.
(Implies `--mirror' and `--mirror-webkit').

=item --berlin

Switch to internal Nokia URLs and make use of the Berlin git mirrors.
(Implies `--mirror' and `--mirror-webkit').


=item --ssh

Use the SSH protocol for git operations.  This may be useful if the git
protocol is blocked by a firewall. Note that this requires a user account
with an uploaded SSH key on all servers used.  (Implies `--nokia-developer').


=item --http

Use the HTTP protocol for git operations.  This may be useful if the git
protocol is blocked by a firewall.  Note that this only works with the
external Gitorious server.


=item --codereview-username <Gerrit/JIRA username>

Adds a gerrit alias to repos under Gerrit codereview management.
This requires a username for SSH access to the codereview.qt.nokia.com
server, which will be the same username you have for the bugtracker at
bugreports.qt.nokia.com.


=item --alternates <path to other Qt5 repo>

Adds alternates for each submodule to another full qt5 checkout. This makes
this qt5 checkout very small, as it will use the object store of the
alternates before unique objects are stored in its own object store.

This option has no effect when using `--no-update'.

B<NOTE:> This will make this repo dependent on the alternate, which is
potentially dangerous!  The dependency can be broken by also using
the `--copy-objects' option, or by running C<git repack -a> in each
submodule, where required.  Please read the note about the `--shared' option
in the documentation of `git clone' for more information.


=item --copy-objects

When `--alternates' is used, automatically do a C<git repack -a> in each
submodule after cloning, to ensure that the repositories are independent
from the source used as a reference for cloning.

Note that this negates the disk usage benefits gained from the use of
`--alternates'.


=item --mirror <url-base>

Uses <url-base> as the base URL for submodule git mirrors.

For example:

  --mirror user@machine:/foo/bar

...will use the following as a mirror for qtbase:

  user@machine:/foo/bar/qtbase.git


=item --mirror-webkit <url>

Uses <url> as the URL for the webkit git mirror.

=back

=cut

use Carp         qw( confess             );
use English      qw( -no_match_vars      );
use Getopt::Long qw( GetOptionsFromArray );
use Pod::Usage   qw( pod2usage           );
use Cwd          qw( getcwd              );

my %PROTOCOLS = (
    'internal'  => 'git://scm.dev.nokia.troll.no/' ,
    'ssh'       => 'git@scm.dev.nokia.troll.no:'   ,
    'http'      => 'http://git.gitorious.org/'     ,
);

my %STAGING_REPOS = map { $_ => "git://gitorious.org/qt/$_-staging.git" } qw(
    qt5
    qt3support
    qtactiveqt
    qtbase
    qtdeclarative
    qtdoc
    qtmultimedia
    qtphonon
    qtqa
    qtscript
    qtsvg
    qttools
    qttranslations
    qtwebkit-examples-and-demos
    qtxmlpatterns
    qtlocation
    qtsensors
    qtsystems
);

my %GERRIT_REPOS = map { $_ => "codereview.qt.nokia.com:qt/$_.git" } qw(
    qtbase
    qtdeclarative
    qtdoc
    qtmultimediakit
);

my $BNE_MIRROR_URL_BASE
    = 'git://bq-git.apac.nokia.com/qtsoftware/qt/';

my $BNE_MIRROR_WEBKIT_URL
    = 'git://bq-git.apac.nokia.com/qtsoftware/research/gitorious-org-webkit-qtwebkit-mirror.git';

my $BER_MIRROR_URL_BASE
    = 'git://ber-git.europe.nokia.com/qt/';

my $BER_MIRROR_WEBKIT_URL
    = 'git://ber-git.europe.nokia.com/qtwebkit/qtwebkit.git';


sub new
{
    my ($class, @arguments) = @_;

    my $self = {};
    bless $self, $class;
    $self->parse_arguments(@arguments);

    return $self;
}

# Like `system', but possibly log the command, and die on non-zero exit code
sub exe
{
    my ($self, @cmd) = @_;

    if (!$self->{quiet}) {
        print "+ @cmd\n";
    }

    if (system(@cmd) != 0) {
        confess "@cmd exited with status $CHILD_ERROR";
    }

    return;
}

sub parse_arguments
{
    my ($self, @args) = @_;

    %{$self} = (%{$self},
        'alternates'          => "",
        'codereview-username' => "",
        'detach-alternates'   => 0 ,
        'force'               => 0 ,
        'ignore-submodules'   => 0 ,
        'mirror-url'          => "",
        'mirror-webkit-url'   => "",
        'nokia-developer'     => 0 ,
        'protocol'            => "",
        'update'              => 1 ,
        'webkit'              => 1 ,
    );

    GetOptionsFromArray(\@args,
        'alternates=s'      =>  \$self->{qw{ alternates        }},
        'codereview-username=s' => \$self->{qw{ codereview-username }},
        'copy-objects'      =>  \$self->{qw{ detach-alternates }},
        'force'             =>  \$self->{qw{ force             }},
        'ignore-submodules' =>  \$self->{qw{ ignore-submodules }},
        'mirror-webkit=s'   =>  \$self->{qw{ mirror-webkit-url }},
        'mirror=s'          =>  \$self->{qw{ mirror-url        }},
        'nokia-developer'   =>  \$self->{qw{ nokia-developer   }},
        'quiet'             =>  \$self->{qw{ quiet             }},
        'update!'           =>  \$self->{qw{ update            }},
        'webkit!'           =>  \$self->{qw{ webkit            }},

        'help|?'            =>  sub { pod2usage(1);               },
        'http'              =>  sub { $self->{protocol} = 'http'; },
        'ssh|ssh-protocol'  =>  sub { $self->{protocol} = 'ssh';  },

        'brisbane|brisbane-nokia-developer' => sub {
            $self->{'nokia-developer'}   = 1;
            $self->{'protocol'}          = 'internal';
            $self->{'mirror-url'}        = $BNE_MIRROR_URL_BASE;
            $self->{'mirror-webkit-url'} = $BNE_MIRROR_WEBKIT_URL;
            $self->{'ignore-submodules'} = 1;
        },

        'berlin|berlin-nokia-developer' => sub {
            $self->{'nokia-developer'}   = 1;
            $self->{'protocol'}          = 'internal';
            $self->{'mirror-url'}        = $BER_MIRROR_URL_BASE;
            $self->{'mirror-webkit-url'} = $BER_MIRROR_WEBKIT_URL;
        },

        'nokia-developer' => sub {
            $self->{'nokia-developer'}   = 1;
            $self->{'protocol'}          = 'internal';
            $self->{'ignore-submodules'} = 1;
        },
    ) || pod2usage(2);

    if ($self->{'nokia-developer'} && $self->{'protocol'} eq 'http') {
        print "*** Ignoring use of HTTP protocol, as it's only usable with external server\n";
        $self->{'protocol'} = '';
    }

    # Replace any double trailing slashes from end of mirror
    $self->{'mirror-url'} =~ s{//+$}{/};

    return;
}

sub check_if_already_initialized
{
    my ($self) = @_;

    # We consider the repo as `initialized' if submodule.qtbase.url is set
    if (qx(git config --get submodule.qtbase.url)) {
        if ($self->{force}) {
            my @configresult = qx(git config -l);
            foreach (@configresult) {
                # Example line: submodule.qtqa.url=git://gitorious.org/qt/qtqa.git
                if (/(submodule\.[^.=]+)\.url=.*/) {
                    $self->exe('git', 'config', '--remove-section', $1);
                }
            }
        }
        else {
            exit 0 if ($self->{quiet});
            print "Will not reinitialize already initialized repository (use -f to force)!\n";
            exit 1;
        }
    }

    return;
}

sub git_submodule_init
{
    my ($self) = @_;

    my @init_args;
    if ($self->{quiet}) {
        push @init_args, '--quiet';
    }
    $self->exe('git', 'submodule', 'init', @init_args);

    my $template = getcwd()."/.commit-template";
    if (-e $template) {
        $self->exe('git', 'config', 'commit.template', $template);
    }

    return;
}

sub git_disable_webkit_submodule
{
    my ($self) = @_;

    $self->exe('git', 'config', '--remove', 'submodule.qtwebkit');
    $self->exe('git', 'config', '--remove', 'submodule.qtwebkit-examples-and-demos');

    return;
}

sub git_set_submodule_config
{
    my ($self) = @_;

    my @configresult          = qx(git config -l);
    my $protocol              = $self->{protocol};
    my $url_base_for_protocol = $PROTOCOLS{$protocol};

    foreach my $line (@configresult) {
        # Example line: submodule.qtqa.url=git://gitorious.org/qt/qtqa.git
        next if ($line !~ /(submodule\.[^.=]+\.url)=(.*)/);

        my $key   = $1;
        my $value = $2;

        if ($protocol) {
            # WebKit is special, and has only external link.
            if ($key ne 'submodule.qtwebkit.url') {
                # qt-labs projects are still hosted under qt internally.
                if ($protocol ne 'http') {
                    $value =~ s,^git://gitorious\.org/qt-labs/,${url_base_for_protocol}qt/,;
                }
                $value =~ s,^git://gitorious\.org/,$url_base_for_protocol,;
            }
        }

        $self->exe('git', 'config', $key, $value);

        if ($self->{'ignore-submodules'}) {
            $key =~ s,\.url,.ignore,;
            $self->exe('git', 'config', $key, 'all');
        }
    }

    return;
}

sub git_clone_all_submodules
{
    my ($self) = @_;

    # manually clone each repo here, so we can easily use reference repos, mirrors and
    # add all staging repos
    my @configresult = qx(git config -l);
    foreach my $line (@configresult) {
        if ($line =~ /submodule\.([^.=]+)\.url=(.*)/) {
            $self->git_clone_one_submodule($1, $2);
        }
    }

    $self->exe('git', 'submodule', 'update');

    return;
}

sub git_add_remotes
{
    my ($self, $repo_basename) = @_;

    my $protocol              = $self->{protocol};
    my $url_base_for_protocol = $PROTOCOLS{$protocol};

    my %current_remotes;
    for my $line (qx(git remote show)) {
        chomp $line;
        $current_remotes{$line} = 1;
    }

    my @gerrit = grep { /^$repo_basename$/; } keys %GERRIT_REPOS;
    if (!$current_remotes{'gerrit'} && $self->{'codereview-username'}) {
        foreach my $gerrit_repo (@gerrit) {
            my $gerrit_repo_url = $GERRIT_REPOS{$gerrit_repo};
            $self->exe('git', 'remote', 'add', 'gerrit', $self->{'codereview-username'}."@".$gerrit_repo_url);
        }
    }

    my @staging = grep { /^$repo_basename$/; } keys %STAGING_REPOS;
    if (!$current_remotes{'staging'}) {
        foreach my $staging_repo (@staging) {
            my $staging_repo_url = $STAGING_REPOS{$staging_repo};
            if ($protocol) {
                if ($protocol ne 'http') {
                    $staging_repo_url =~ s,^git://gitorious\.org/qt-labs/,${url_base_for_protocol}qt/,;
                }
                $staging_repo_url =~ s,^git://gitorious\.org/,$url_base_for_protocol,;
            }
            $self->exe('git', 'remote', 'add', 'staging', $staging_repo_url);
        }
    }

    # if repo has no staging repo defined, alias it to gerrit or origin
    if (!$current_remotes{'staging'} && !@staging) {
        my @configresult = qx(git remote -v);
        my $staging_set = 0;
        foreach (@configresult) {
            if (/^gerrit\s+(\S+) \(fetch\)/) {
                $self->exe('git', 'remote', 'add', 'staging', $1);
                $staging_set = 1;
            }
        }
        unless($staging_set) {
            foreach (@configresult) {
                if (/^origin\s+(\S+) \(fetch\)/) {
                    $self->exe('git', 'remote', 'add', 'staging', $1);
                }
            }
        }
    }
    #if repo has no gerrit repo defined, alias it to whatever staging now points to (could be origin)
    if (!$current_remotes{'gerrit'} && !@gerrit) {
        my @configresult = qx(git remote -v);
        foreach (@configresult) {
            if (/^staging\s+(\S+) \(fetch\)/) {
                $self->exe('git', 'remote', 'add', 'gerrit', $1);
            }
        }
    }

    return;
}

sub git_clone_one_submodule
{
    my ($self, $submodule, $url) = @_;

    my $alternates            = $self->{ 'alternates'        };
    my $mirror_url            = $self->{ 'mirror-url'        };
    my $mirror_webkit_url     = $self->{ 'mirror-webkit-url' };

    # `--reference FOO' args for the clone, if any.
    my @reference_args;

    if ($alternates) {
        # alternates is a qt5 repo, so the submodule will be under that.
        if (-d "$alternates/$submodule") {
            @reference_args = ('--reference', "$alternates/$submodule");
        }
        else {
            print " *** $alternates/$submodule not found, ignoring alternate for this submodule\n";
        }
    }

    my $mirror;
    if ($mirror_url && ($submodule ne 'qtwebkit')) {
        $mirror = $mirror_url.$submodule;
        $mirror .= ".git" unless (-d $mirror); # Support local disk mirror
    }
    elsif ($mirror_webkit_url && ($submodule eq 'qtwebkit')) {
        $mirror = $mirror_webkit_url;
    }

    my $do_clone = (! -d "$submodule/.git");
    if ($do_clone) {
        $self->exe('git', 'clone', @reference_args, ($mirror ? $mirror : $url), $submodule);
    }

    chdir($submodule) or confess "chdir $submodule: $OS_ERROR";

    if (!$do_clone) {
        $self->exe('git', 'fetch', ($mirror ? $mirror : $url));
    }

    my $template = getcwd()."/../.commit-template";
    if (-e $template) {
        $self->exe('git', 'config', 'commit.template', $template);
    }

    if ($mirror) {
        $self->exe('git', 'config', 'remote.origin.url', $url);

        # In `force' mode, remove the mirror if it already exists,
        # since we may be reinitializing the module.
        if ($self->{force}) {
            eval { $self->exe('git', 'remote', 'rm', 'mirror'); }; # failure is OK
        }

        $self->exe('git', 'remote', 'add', 'mirror', $mirror);
    }

    $self->git_add_remotes($submodule);

    if ($self->{'detach-alternates'}) {
        $self->exe('git', 'repack', '-a');

        my $alternates_path = '.git/objects/info/alternates';
        unlink($alternates_path) || confess "unlink $alternates_path: $OS_ERROR";
    }

    if ($submodule eq "qtdeclarative") { #Extra step needed to setup declarative 
        $self->exe('git', 'submodule', 'init'); 
        $self->exe('git', 'submodule', 'update'); 
    } 

    chdir("..") or confess "cd ..: $OS_ERROR";

    return;
}

sub run
{
    my ($self) = @_;

    $self->check_if_already_initialized;
    $self->git_submodule_init;

    if (!$self->{webkit}) {
        $self->git_disable_webkit_submodule;
    }

    $self->git_set_submodule_config;

    if ($self->{update}) {
        $self->git_clone_all_submodules;
    }

    $self->git_add_remotes('qt5');

    return;
}

#==============================================================================

Qt::InitRepository->new(@ARGV)->run if (!caller);
1;
